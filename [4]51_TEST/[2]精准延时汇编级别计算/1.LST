C51 COMPILER V9.59.0.0   1                                                                 12/23/2018 23:09:22 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE 1
OBJECT MODULE PLACED IN 1.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE 1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          
   4          
   5          typedef unsigned char BYTE;
   6          typedef unsigned int WORD;
   7          
   8          #define FOSC 11059200L      //System frequency
   9          #define BAUD 9600           //UART baudrate
  10          
  11          /*Define UART parity mode*/
  12          #define NONE_PARITY     0   //None parity
  13          #define ODD_PARITY      1   //Odd parity
  14          #define EVEN_PARITY     2   //Even parity
  15          #define MARK_PARITY     3   //Mark parity
  16          #define SPACE_PARITY    4   //Space parity
  17          
  18          #define PARITYBIT EVEN_PARITY   //Testing even parity
  19          
  20          sbit bit9 = P2^2;           //P2.2 show UART data bit9
  21          bit busy;
  22          
  23          void SendData(BYTE dat);
  24          void SendString(char *s);
  25          
  26          
  27          //11.0529MHz 表示1us的时间内，有11.0592次震荡
  28          //11.0592/12=0.9216个指令周期,就是1us，1个指令周期就是1.08506944us
  29          //定时器定时100us，实际上为1.08506944 * 92 =99.826388us
  30          //误差为1-99.826388/100 =1-0.99826388=0.173612%
  31          //定时1000ms的时候，误差为少了0.17*10000=1700us =1.7ms
  32          //弥补误差(每1ms增加两个指令)后，误差为1-(998.26388+2*1.08506944)/1000=1-0.99956617=0.0434%
  33          //定时1ms实际上为1.00043402ms 定时1000ms为1000.43402ms 多了0.43ms
  34          void Delayms(int nms)   //@11.0592MHz
  35          {
  36   1          int n100us;
  37   1          char count;
  38   1          TR0=1;
  39   1          count=0;
  40   1          n100us=nms*10;//100us一次定时器中断
  41   1          while(n100us--)
  42   1          {
  43   2            if(count==10)//修正误差
  44   2            {
  45   3              while(TF0==0);
  46   3              TR0=0;  //先关闭计时器，再修正误差
  47   3              _nop_();//修正误差指令1
  48   3              TR0=1;  //修正误差指令2,共两个指令周期,第三个指令周期重新开始计时
  49   3              count=0;
  50   3              TF0=0;
  51   3            }
  52   2            else
  53   2            {
  54   3              while(TF0==0);
  55   3              TF0=0;
C51 COMPILER V9.59.0.0   1                                                                 12/23/2018 23:09:22 PAGE 2   

  56   3            }
  57   2            count++;
  58   2          }
  59   1          TR0=0;
  60   1      }
  61          void Delay1000ms()    //@11.0592MHz
  62          {
  63   1        unsigned char i, j, k;
  64   1      
  65   1        _nop_();
  66   1        i = 8;
  67   1        j = 1;
  68   1        k = 243;
  69   1        do
  70   1        {
  71   2          do
  72   2          {
  73   3            while (--k);
  74   3          } while (--j);
  75   2        } while (--i);
  76   1      }
  77          
  78          
  79          void Timer0Init(void)   //1us@11.0592MHz
  80          {
  81   1        TR0 = 0;    //定时器1开始计时
  82   1        TMOD &= 0xF0;   //设置定时器模式
  83   1        TMOD |= 0x02;   //设置定时器模式
  84   1        TL0 = 0xA4;   //设置定时初值
  85   1        TH0 = 0xA4;   //设置定时重载值
  86   1        TF0 = 0;    //清除TF0标志
  87   1      }
  88          
  89          void main()
  90          {
  91   1      #if (PARITYBIT == NONE_PARITY)
                  SCON = 0x50;            //8-bit variable UART
              #elif (PARITYBIT == ODD_PARITY) || (PARITYBIT == EVEN_PARITY) || (PARITYBIT == MARK_PARITY)
  94   1          SCON = 0xda;            //9-bit variable UART, parity bit initial to 1
  95   1      #elif (PARITYBIT == SPACE_PARITY)
                  SCON = 0xd2;            //9-bit variable UART, parity bit initial to 0
              #endif
  98   1      
  99   1          TMOD = 0x20;            //Set Timer1 as   8-bit auto reload mode
 100   1          TH1 = TL1 = -(FOSC/12/32/BAUD); //Set auto-reload vaule
 101   1          TR1 = 1;                //Timer1 start run
 102   1          ES = 1;                 //Enable UART interrupt
 103   1          EA = 1;                 //Open master interrupt switch
 104   1          Timer0Init();
 105   1          while(1)
 106   1        {
 107   2            Delay1000ms();
 108   2            SBUF='A';
 109   2        };
 110   1      }
 111          
 112          
 113          /*--`--------------------------
 114          UART interrupt service routine
 115          ----------------------------*/
 116          void Uart_Isr() interrupt 4 using 1
 117          {
C51 COMPILER V9.59.0.0   1                                                                 12/23/2018 23:09:22 PAGE 3   

 118   1          if (RI)
 119   1          {
 120   2              RI = 0;             //Clear receive interrupt flag
 121   2              P0 = SBUF;          //P0 show UART data
 122   2              bit9 = RB8;         //P2.2 show parity bit
 123   2          }
 124   1          if (TI)
 125   1          {
 126   2              TI = 0;             //Clear transmit interrupt flag
 127   2              busy = 0;           //Clear transmit busy flag
 128   2          }
 129   1      }
 130          
 131          /*----------------------------
 132          Send a byte data to UART
 133          Input: dat (data to be sent)
 134          Output:None
 135          ----------------------------*/
 136          void SendData(BYTE dat)
 137          {
 138   1          while (busy);           //Wait for the completion of the previous data is sent
 139   1          ACC = dat;              //Calculate the even parity bit P (PSW.0)
 140   1          if (P)                  //Set the parity bit according to P
 141   1          { 
 142   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 0;            //Set parity bit to 0
              #elif (PARITYBIT == EVEN_PARITY)
 145   2              TB8 = 1;            //Set parity bit to 1
 146   2      #endif
 147   2          }
 148   1          else
 149   1          {
 150   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 1;            //Set parity bit to 1
              #elif (PARITYBIT == EVEN_PARITY)
 153   2              TB8 = 0;            //Set parity bit to 0
 154   2      #endif
 155   2          }
 156   1          busy = 1;
 157   1          SBUF = ACC;             //Send data to UART buffer
 158   1      }
 159          
 160          /*----------------------------
 161          Send a string to UART
 162          Input: s (address of string)
 163          Output:None
 164          ----------------------------*/
 165          void SendString(char *s)
 166          {
 167   1          while (*s)              //Check the end of the string
 168   1          {
 169   2              SendData(*s++);     //Send current char and increment string ptr
 170   2          }
 171   1      }
 172          
 173          
 174          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    196    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.59.0.0   1                                                                 12/23/2018 23:09:22 PAGE 4   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
