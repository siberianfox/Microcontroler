C51 COMPILER V9.59.0.0   MAIN                                                              12/13/2018 11:32:11 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5_2\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\ma
                    -in.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15W.H>
   2          #include <intrins.h>
   3          /*P1口0-5用作控制IO，模拟SPI协议探测能否读取到模块信息*/
   4          //CPHA=0 CPOL=0  SPI第一个跳边沿数据有效，SPI闲状态线为高电平
   5          char IO=0xff;
   6          char MOSI_Bit=0, MISO_Bit=0, SCLK_Bit=0, CS_Bit=0;//剩余的两个引脚可以不管 ：CE IRQ
   7          
   8          void Delay1000ms()    //@11.0592MHz
   9          {
  10   1        unsigned char i, j, k;
  11   1      
  12   1        _nop_();
  13   1        _nop_();
  14   1        i = 43;
  15   1        j = 6;
  16   1        k = 203;
  17   1        do
  18   1        {
  19   2          do
  20   2          {
  21   3            while (--k);
  22   3          } while (--j);
  23   2        } while (--i);
  24   1      }
  25          
  26          void UartInit(void)   //9600bps@11.0592MHz
  27          {
  28   1          SCON = 0x50;      //8位数据，可变波特率
  29   1          AUXR |= 0x01;     
  30   1          AUXR |= 0x04;     //定时器时钟为Fosc，1T模式
  31   1          T2L = 0xE0;       //定时器初值，内部时钟11.0592M，波特率9600
  32   1          T2H = 0xFE;       //定时器初值
  33   1          AUXR |= 0x10;     //启动定时器
  34   1          //ES=1;           //串口中断开关,采用查询法时不用打开中断      
  35   1          REN=1;            //串口为工作方式1，允许接收数据
  36   1          SM0=0;            //SM0 SM1串口工作方式选择，01：8位异步收发，波特率由定时器决定
  37   1          SM1=1;
  38   1      }
  39          
  40          void SneString(char *Str)
  41          {
  42   1          while(*Str!=0)
  43   1          {
  44   2            SBUF=*Str;
  45   2            while(!TI);           //等待发送完成
  46   2            TI=0;               //清零发送标志位
  47   2            Str++;
  48   2          }
  49   1      }
  50          
  51          int main()
  52          {
  53   1        char i,j,k,l;
  54   1        UartInit();
C51 COMPILER V9.59.0.0   MAIN                                                              12/13/2018 11:32:11 PAGE 2   

  55   1        P1=IO;//所有引脚都输出1
  56   1        /*开始探测IO口是否正确,有反应的条件:芯片的FIFO不为空或者其他两个引脚（CE、IRQ被拉低）*/
  57   1        while(1)
  58   1        {
  59   2          for(i=0;i<=5;i++)
  60   2          {
  61   3            /*选定一个IO，逐个选择*/
  62   3            if(i==0)
  63   3              MOSI_Bit=0;
  64   3            else
  65   3              MOSI_Bit++;
  66   3            
  67   3            for(j=0;j<=4;j++)
  68   3              {
  69   4                MOSI_Bit=0;
  70   4      
  71   4              for(k=0;k<=3;k++)
  72   4                {
  73   5                  for(l=0;l<=2;l++)//在此进行探测，并通过串口发送结果
  74   5                  {
  75   6                    
  76   6                  }
  77   5                }
  78   4              }
  79   3          };
  80   2          Delay1000ms();
  81   2          SneString("Hello world");
  82   2        }
  83   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    188    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
